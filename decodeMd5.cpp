//
//  decodeMd5.cpp
//  md5decrypt
//
//  Created by Dr. Akshay P on 8/27/15.
//  Copyright (c) 2015 Dr. Akshay P. All rights reserved.
//  Uses MD5 open-source C++ implementation, with copyrights displayed

/* this is the major code written by me, uses open-source md5 implementation*/

/* the code below wont work since 'input' and 'e' are not filled */

#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <string.h>
#include <algorithm>
#include <stdlib.h>

#include "md5.h"
#include "decodeMd5.h"

using namespace std;

string decodeMd5()
{
    string input = ""; //need to fill with existing hash, which was generated by repetitive nested MD5 encryption
    string e = "user@usermail.com";
    vector<string> hashes;
    
    for (int i = 0; i < input.length() / 32; ++i)
    {
        hashes.push_back(input.substr(32 * i, 32));
        cout << (hashes[hashes.size() - 1]) << endl;
    }
    
    cout << endl;
    
    string resultingEmail;
    string validChars = "_.+@1234567890";
    stringstream sb1;
    string tmp1;
    
    /* building validChars to have lower-case, upper-case alphabtes and numbers 0-9 */
    for (int inp = 'a'; inp <= 'z'; ++inp)
    {
        sb1 << char(inp);
    }
    
    validChars += sb1.str();
    string tmp=sb1.str();
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), static_cast < int(*)(int) > (toupper));
    validChars += tmp;
    
    
    for (int k = 0; k < hashes.size(); ++k)
    {
        bool found = false;
        /* if the string has an odd number of characters, in that case for the last single character */
        for (int i = 0; i < validChars.length() && !found; ++i)
        {
            stringstream sb;
            sb << (validChars[i]);
            string token = resultingEmail + sb.str();
            
            if (hashes[k] == md5(md5(e) + token + md5(token)))
            {
                cout << "1-Token:=" << token << " - " << hashes[k] << " - " << md5(md5(e) + token + md5(token)) << "\n";
                resultingEmail = token;
                found = true;
            }
        }
        
        /* brute-forcing 2 characters at each iteration and matching the md5 with 32-bit input string */
        for (int i = 0; i < validChars.length() && !found; ++i)
        {
            for (int j = 0; j < validChars.length() && !found; ++j)
            {
                stringstream sb;
                sb << (validChars[i]);
                sb << (validChars[j]);
                string token = resultingEmail + sb.str();
                
                if (hashes[k] == md5(md5(e) + token + md5(token)))
                {
                    cout << "2-Token:=" << token << " - " << hashes[k] << " - " << md5(md5(e) + token + md5(token)) << "\n";
                    resultingEmail = token;
                    found = true;
                }
            }
        }
    }
    return resultingEmail;
}